<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AlfieVR - Stereo 3D Vision</title>
    <meta name="description" content="Stereo 3D Vision for Meta Quest 3">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }
        
        #status {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            border: 1px solid #333;
        }
        
        #status.connected {
            border-color: #4CAF50;
            color: #4CAF50;
        }
        
        #status.error {
            border-color: #f44336;
            color: #f44336;
        }
        
        #vrButton {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 16px 48px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 12px;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
        }
        
        #vrButton:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 6px 30px rgba(102, 126, 234, 0.6);
        }
        
        #vrButton:disabled {
            background: #444;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        #previewContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 20px;
            align-items: center;
            z-index: 100;
        }
        
        #rgbPreview {
            max-width: 35%;
            max-height: 80vh;
            border: 2px solid #3498db;
            border-radius: 8px;
            background: #111;
        }
        
        #rgbPreview.disconnected {
            opacity: 0.3;
            border-color: #666;
        }
        
        .preview-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .preview-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #888;
            white-space: nowrap;
        }
        
        #preview {
            max-width: 55%;
            max-height: 80vh;
            border: 2px solid #4CAF50;
            border-radius: 8px;
        }
        
        .hidden {
            display: none !important;
        }
        
        #info {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 12px;
            color: #888;
            z-index: 1000;
        }
        
        #controls {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #444;
            z-index: 1000;
            font-size: 16px;
            min-width: 286px;
        }
        
        #controls h3 {
            margin: 0 0 13px 0;
            color: #4CAF50;
            font-size: 18px;
            cursor: move;
            user-select: none;
            padding: 5px;
            margin: -5px -5px 13px -5px;
            border-radius: 5px;
        }
        
        #controls h3:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .control-row {
            display: flex;
            align-items: center;
            margin: 10px 0;
            gap: 10px;
        }
        
        .control-row label {
            flex: 0 0 130px;
            color: #aaa;
        }
        
        .control-row input[type="range"] {
            flex: 1;
            min-width: 104px;
            height: 16px;
        }
        
        .control-row .value {
            flex: 0 0 65px;
            text-align: right;
            color: #fff;
            font-family: monospace;
        }
        
        .control-btn {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 7px 13px;
            border-radius: 5px;
            cursor: pointer;
            margin: 3px;
            font-size: 13px;
        }
        
        .control-btn:hover {
            background: #444;
        }

        canvas {
            display: none;
        }
        
        #rgbControls {
            position: fixed;
            top: 70px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #3498db;
            z-index: 1000;
            font-size: 16px;
            min-width: 286px;
        }
        
        #rgbControls h3 {
            margin: 0 0 13px 0;
            color: #3498db;
            font-size: 18px;
            cursor: move;
            user-select: none;
            padding: 5px;
            margin: -5px -5px 13px -5px;
            border-radius: 5px;
        }
        
        #rgbControls h3:hover {
            background: rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body>
    <div id="status">Initializing...</div>
    <video id="stereoVideo" autoplay playsinline muted style="display: none;"></video>
    <video id="rgbVideo" autoplay playsinline muted style="display: none;"></video>
    <canvas id="leftCanvas"></canvas>
    <canvas id="rightCanvas"></canvas>
    
    <!-- Desktop preview container -->
    <div id="previewContainer" class="hidden">
        <div class="preview-wrapper">
            <span class="preview-label">üé• RGB Camera</span>
            <img id="rgbPreview" class="disconnected" alt="RGB preview">
        </div>
        <div class="preview-wrapper">
            <span class="preview-label">üëÅÔ∏è Stereo 3D</span>
            <img id="preview" alt="Stereo preview">
        </div>
    </div>
    
    <!-- Stereo adjustment controls -->
    <div id="controls">
        <h3>üéØ Stereo Adjustments</h3>
        <div class="control-row">
            <label>Vertical Offset</label>
            <input type="range" id="verticalOffset" min="-1" max="1" step="0.01" value="0">
            <span class="value" id="verticalOffsetVal">0.00</span>
        </div>
        <div class="control-row">
            <label>IPD Offset</label>
            <input type="range" id="ipdOffset" min="-0.05" max="0.05" step="0.001" value="0">
            <span class="value" id="ipdOffsetVal">0.000</span>
        </div>
        <div class="control-row">
            <label>Screen Distance</label>
            <input type="range" id="screenDistance" min="0.5" max="5" step="0.1" value="2">
            <span class="value" id="screenDistanceVal">2.0</span>
        </div>
        <div class="control-row">
            <label>Screen Scale</label>
            <input type="range" id="screenScale" min="0.5" max="3" step="0.1" value="1.5">
            <span class="value" id="screenScaleVal">1.5</span>
        </div>
        <div class="control-row">
            <label>Curvature</label>
            <input type="range" id="curvature" min="0" max="1" step="0.05" value="0">
            <span class="value" id="curvatureVal">0.00</span>
        </div>
        <div class="control-row">
            <button class="control-btn" onclick="resetSettings()">Reset</button>
            <button class="control-btn" onclick="saveSettings()">Save</button>
        </div>
    </div>
    
    <!-- RGB Panel controls -->
    <div id="rgbControls">
        <h3>üé• RGB Panel (VR)</h3>
        <div class="control-row">
            <label>Enabled</label>
            <input type="checkbox" id="rgbEnabled" checked style="width: 20px; height: 20px;">
            <span class="value"></span>
        </div>
        <div class="control-row">
            <label>Angle (¬∞)</label>
            <input type="range" id="rgbXOffset" min="-90" max="90" step="5" value="45">
            <span class="value" id="rgbXOffsetVal">45¬∞</span>
        </div>
        <div class="control-row">
            <label>Vertical Pos</label>
            <input type="range" id="rgbYOffset" min="-2" max="2" step="0.05" value="-0.5">
            <span class="value" id="rgbYOffsetVal">-0.50</span>
        </div>
        <div class="control-row">
            <label>Scale</label>
            <input type="range" id="rgbScale" min="0.1" max="1" step="0.05" value="0.4">
            <span class="value" id="rgbScaleVal">0.40</span>
        </div>
        <div class="control-row">
            <label>Distance</label>
            <input type="range" id="rgbDistance" min="0.5" max="3" step="0.1" value="1.5">
            <span class="value" id="rgbDistanceVal">1.5</span>
        </div>
        <div class="control-row">
            <button class="control-btn" onclick="resetRGBSettings()">Reset</button>
            <button class="control-btn" onclick="saveRGBSettings()">Save</button>
        </div>
    </div>
    
    <div id="info">
        Put on your Meta Quest 3 and click "Enter VR" for immersive 3D vision<br>
        Use thumbsticks in VR: Left stick = vertical, Right stick = IPD | Triggers = distance
    </div>
    <button id="vrButton" disabled>ü•Ω Enter VR</button>
    <button id="certButton" style="position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%); background: #f39c12; color: #000; border: none; padding: 12px 24px; font-size: 14px; border-radius: 8px; cursor: pointer; z-index: 1000; display: none;">üîê Accept Stereo Stream Certificate</button>
    <button id="rgbCertButton" style="position: fixed; bottom: 150px; left: 50%; transform: translateX(-50%); background: #3498db; color: #fff; border: none; padding: 12px 24px; font-size: 14px; border-radius: 8px; cursor: pointer; z-index: 1000; display: none;">üîê Accept RGB Stream Certificate</button>

    <script type="module">
        // WebXR Stereo Vision for Meta Quest 3
        // Displays side-by-side stereo video as immersive VR
        
        const STEREO_SIGNALING_PORT = 8084;
        const RGB_SIGNALING_PORT = 8083;
        
        // Stereo stream state
        let pc = null;
        let xrSession = null;
        let xrRefSpace = null;
        let gl = null;
        let leftTexture = null;
        let rightTexture = null;
        let videoElement = null;
        let leftCanvas, rightCanvas, leftCtx, rightCtx;
        let retryCount = 0;
        const MAX_RETRIES = 3;
        
        // RGB stream state
        let rgbPc = null;
        let rgbVideoElement = null;
        let rgbRetryCount = 0;
        let rgbConnected = false;
        
        // RGB VR panel state
        let rgbTexture = null;
        let rgbCanvas = null;
        let rgbCtx = null;
        let rgbPanelShader = null;
        let rgbPositionBuffer = null;
        let rgbTexCoordBuffer = null;
        
        // RGB VR panel settings (head-locked corner panel)
        let rgbPanelSettings = {
            enabled: true,          // Show RGB panel in VR
            scale: 0.4,             // Size relative to main screen
            angle: 45,              // Angle in degrees (positive = right, negative = left)
            yOffset: -0.5,          // Offset down (meters)
            distance: 1.5           // Distance from viewer (meters)
        };
        
        // Stereo adjustment settings
        let stereoSettings = {
            verticalOffset: 0,      // Meters - positive = up
            ipdOffset: 0,           // Meters - adjustment to convergence
            screenDistance: 2.0,    // Meters - distance to virtual screen
            screenScale: 1.5,       // Multiplier for screen size
            curvature: 0            // 0 = flat, 1 = fully curved (cylindrical)
        };
        
        // Load saved settings
        function loadSettings() {
            try {
                const saved = localStorage.getItem('stereoVRSettings');
                if (saved) {
                    stereoSettings = { ...stereoSettings, ...JSON.parse(saved) };
                }
            } catch (e) {}
            updateControlsFromSettings();
        }
        
        // Save settings to localStorage
        window.saveSettings = function() {
            localStorage.setItem('stereoVRSettings', JSON.stringify(stereoSettings));
            setStatus('Settings saved!', 'connected');
            setTimeout(() => setStatus('VR Active - Stereo 3D Vision', 'connected'), 1000);
        };
        
        // Reset settings to defaults
        window.resetSettings = function() {
            stereoSettings = {
                verticalOffset: 0,
                ipdOffset: 0,
                screenDistance: 2.0,
                screenScale: 1.5,
                curvature: 0
            };
            updateControlsFromSettings();
            reinitQuadBuffers();
        };
        
        // Update HTML controls to match settings
        function updateControlsFromSettings() {
            document.getElementById('verticalOffset').value = stereoSettings.verticalOffset;
            document.getElementById('verticalOffsetVal').textContent = stereoSettings.verticalOffset.toFixed(2);
            document.getElementById('ipdOffset').value = stereoSettings.ipdOffset;
            document.getElementById('ipdOffsetVal').textContent = stereoSettings.ipdOffset.toFixed(3);
            document.getElementById('screenDistance').value = stereoSettings.screenDistance;
            document.getElementById('screenDistanceVal').textContent = stereoSettings.screenDistance.toFixed(1);
            document.getElementById('screenScale').value = stereoSettings.screenScale;
            document.getElementById('screenScaleVal').textContent = stereoSettings.screenScale.toFixed(1);
            document.getElementById('curvature').value = stereoSettings.curvature;
            document.getElementById('curvatureVal').textContent = stereoSettings.curvature.toFixed(2);
        }
        
        // Set up control event listeners
        function setupControls() {
            document.getElementById('verticalOffset').addEventListener('input', (e) => {
                stereoSettings.verticalOffset = parseFloat(e.target.value);
                document.getElementById('verticalOffsetVal').textContent = stereoSettings.verticalOffset.toFixed(2);
                reinitQuadBuffers();
            });
            document.getElementById('ipdOffset').addEventListener('input', (e) => {
                stereoSettings.ipdOffset = parseFloat(e.target.value);
                document.getElementById('ipdOffsetVal').textContent = stereoSettings.ipdOffset.toFixed(3);
            });
            document.getElementById('screenDistance').addEventListener('input', (e) => {
                stereoSettings.screenDistance = parseFloat(e.target.value);
                document.getElementById('screenDistanceVal').textContent = stereoSettings.screenDistance.toFixed(1);
            });
            document.getElementById('screenScale').addEventListener('input', (e) => {
                stereoSettings.screenScale = parseFloat(e.target.value);
                document.getElementById('screenScaleVal').textContent = stereoSettings.screenScale.toFixed(1);
                reinitQuadBuffers();
            });
            document.getElementById('curvature').addEventListener('input', (e) => {
                stereoSettings.curvature = parseFloat(e.target.value);
                document.getElementById('curvatureVal').textContent = stereoSettings.curvature.toFixed(2);
                reinitQuadBuffers();
            });
        }
        
        // Load saved RGB panel settings
        function loadRGBSettings() {
            try {
                const saved = localStorage.getItem('rgbPanelSettings');
                if (saved) {
                    rgbPanelSettings = { ...rgbPanelSettings, ...JSON.parse(saved) };
                }
            } catch (e) {}
            updateRGBControlsFromSettings();
        }
        
        // Save RGB panel settings to localStorage
        window.saveRGBSettings = function() {
            localStorage.setItem('rgbPanelSettings', JSON.stringify(rgbPanelSettings));
            setStatus('RGB panel settings saved!', 'connected');
            setTimeout(() => setStatus('Stereo stream connected', 'connected'), 1000);
        };
        
        // Reset RGB panel settings to defaults
        window.resetRGBSettings = function() {
            rgbPanelSettings = {
                enabled: true,
                scale: 0.4,
                angle: 45,
                yOffset: -0.5,
                distance: 1.5
            };
            updateRGBControlsFromSettings();
        };
        
        // Update RGB panel HTML controls to match settings
        function updateRGBControlsFromSettings() {
            document.getElementById('rgbEnabled').checked = rgbPanelSettings.enabled;
            document.getElementById('rgbXOffset').value = rgbPanelSettings.angle;
            document.getElementById('rgbXOffsetVal').textContent = rgbPanelSettings.angle + '¬∞';
            document.getElementById('rgbYOffset').value = rgbPanelSettings.yOffset;
            document.getElementById('rgbYOffsetVal').textContent = rgbPanelSettings.yOffset.toFixed(2);
            document.getElementById('rgbScale').value = rgbPanelSettings.scale;
            document.getElementById('rgbScaleVal').textContent = rgbPanelSettings.scale.toFixed(2);
            document.getElementById('rgbDistance').value = rgbPanelSettings.distance;
            document.getElementById('rgbDistanceVal').textContent = rgbPanelSettings.distance.toFixed(1);
        }
        
        // Set up RGB panel control event listeners
        function setupRGBControls() {
            document.getElementById('rgbEnabled').addEventListener('change', (e) => {
                rgbPanelSettings.enabled = e.target.checked;
            });
            document.getElementById('rgbXOffset').addEventListener('input', (e) => {
                rgbPanelSettings.angle = parseFloat(e.target.value);
                document.getElementById('rgbXOffsetVal').textContent = rgbPanelSettings.angle + '¬∞';
            });
            document.getElementById('rgbYOffset').addEventListener('input', (e) => {
                rgbPanelSettings.yOffset = parseFloat(e.target.value);
                document.getElementById('rgbYOffsetVal').textContent = rgbPanelSettings.yOffset.toFixed(2);
            });
            document.getElementById('rgbScale').addEventListener('input', (e) => {
                rgbPanelSettings.scale = parseFloat(e.target.value);
                document.getElementById('rgbScaleVal').textContent = rgbPanelSettings.scale.toFixed(2);
            });
            document.getElementById('rgbDistance').addEventListener('input', (e) => {
                rgbPanelSettings.distance = parseFloat(e.target.value);
                document.getElementById('rgbDistanceVal').textContent = rgbPanelSettings.distance.toFixed(1);
            });
        }
        
        // Reinitialize quad buffers when size changes
        function reinitQuadBuffers() {
            if (gl && positionBuffer) {
                const aspect = 16 / 9;
                const height = stereoSettings.screenScale;
                const width = height * aspect;
                const yOffset = stereoSettings.verticalOffset;
                
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    -width/2, -height/2 + yOffset,
                     width/2, -height/2 + yOffset,
                    -width/2,  height/2 + yOffset,
                     width/2,  height/2 + yOffset,
                ]), gl.STATIC_DRAW);
            }
        }
        
        // Status display
        function setStatus(text, type = '') {
            const status = document.getElementById('status');
            status.textContent = text;
            status.className = type;
        }
        
        // Show certificate button for user to accept SSL cert (stereo stream)
        function showStereoCertButton() {
            const btn = document.getElementById('certButton');
            btn.style.display = 'block';
            btn.onclick = () => {
                // Open the stereo signaling URL in a new tab so user can accept cert
                window.open(`https://${window.location.hostname}:${STEREO_SIGNALING_PORT}/`, '_blank');
                setStatus('Accept the certificate in the new tab, then reload this page', 'error');
            };
        }
        
        // Show certificate button for user to accept SSL cert (RGB stream)
        function showRGBCertButton() {
            const btn = document.getElementById('rgbCertButton');
            btn.style.display = 'block';
            btn.onclick = () => {
                // Open the RGB signaling URL in a new tab so user can accept cert
                window.open(`https://${window.location.hostname}:${RGB_SIGNALING_PORT}/`, '_blank');
                setStatus('Accept the RGB certificate in the new tab, then reload this page', 'error');
            };
        }
        
        // Initialize WebRTC connection to stereo stream
        async function initStereoWebRTC() {
            setStatus('Connecting to stereo stream...');
            
            const signalingUrl = `https://${window.location.hostname}:${STEREO_SIGNALING_PORT}/offer`;
            
            pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });
            
            pc.ontrack = (event) => {
                console.log('Track received:', event.track.kind);
                if (event.track.kind === 'video') {
                    videoElement = document.getElementById('stereoVideo');
                    videoElement.srcObject = event.streams[0];
                    videoElement.play().then(() => {
                        setStatus('Stereo stream connected', 'connected');
                        document.getElementById('vrButton').disabled = false;
                        document.getElementById('certButton').style.display = 'none';
                        startPreview();
                    }).catch(err => {
                        console.error('Video play error:', err);
                        setStatus('Video play error: ' + err.message, 'error');
                    });
                }
            };
            
            pc.oniceconnectionstatechange = () => {
                console.log('Stereo ICE state:', pc.iceConnectionState);
                if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {
                    setStatus('Stereo connection lost, reconnecting...', 'error');
                    setTimeout(initStereoWebRTC, 2000);
                }
            };
            
            // Add transceiver for video
            pc.addTransceiver('video', { direction: 'recvonly' });
            
            try {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                // Wait for ICE gathering
                await new Promise((resolve) => {
                    if (pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        const checkState = () => {
                            if (pc.iceGatheringState === 'complete') {
                                pc.removeEventListener('icegatheringstatechange', checkState);
                                resolve();
                            }
                        };
                        pc.addEventListener('icegatheringstatechange', checkState);
                        // Timeout after 3 seconds
                        setTimeout(resolve, 3000);
                    }
                });
                
                const response = await fetch(signalingUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sdp: pc.localDescription.sdp,
                        type: pc.localDescription.type
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Signaling failed: ${response.status}`);
                }
                
                const answer = await response.json();
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
                
                console.log('WebRTC connection established');
                retryCount = 0;  // Reset retry count on success
                
            } catch (err) {
                console.error('Stereo WebRTC error:', err);
                retryCount++;
                
                // Check if it's likely a certificate error
                if (err.message.includes('fetch') || err.message.includes('Failed') || err.name === 'TypeError') {
                    setStatus('Stereo connection error - SSL certificate may need to be accepted', 'error');
                    showStereoCertButton();
                    
                    if (retryCount <= MAX_RETRIES) {
                        setTimeout(initStereoWebRTC, 5000);
                    }
                } else {
                    setStatus('Stereo connection error: ' + err.message, 'error');
                    setTimeout(initStereoWebRTC, 3000);
                }
            }
        }
        
        // Initialize WebRTC connection to RGB stream (port 8083)
        async function initRGBWebRTC() {
            console.log('Connecting to RGB stream...');
            
            const signalingUrl = `https://${window.location.hostname}:${RGB_SIGNALING_PORT}/offer`;
            
            rgbPc = new RTCPeerConnection({
                iceServers: [], // Direct connection, no STUN/TURN needed on LAN
                sdpSemantics: 'unified-plan',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            });
            
            rgbPc.ontrack = (event) => {
                console.log('RGB track received:', event.track.kind);
                if (event.track.kind === 'video') {
                    rgbVideoElement = document.getElementById('rgbVideo');
                    rgbVideoElement.srcObject = event.streams[0];
                    rgbVideoElement.play().then(() => {
                        console.log('RGB stream connected');
                        rgbConnected = true;
                        document.getElementById('rgbCertButton').style.display = 'none';
                    }).catch(err => {
                        console.error('RGB video play error:', err);
                    });
                }
            };
            
            rgbPc.oniceconnectionstatechange = () => {
                console.log('RGB ICE state:', rgbPc.iceConnectionState);
                if (rgbPc.iceConnectionState === 'failed' || rgbPc.iceConnectionState === 'disconnected') {
                    console.log('RGB connection lost, reconnecting...');
                    rgbConnected = false;
                    setTimeout(initRGBWebRTC, 2000);
                }
            };
            
            // Add transceiver for video
            rgbPc.addTransceiver('video', { direction: 'recvonly' });
            
            try {
                const offer = await rgbPc.createOffer();
                await rgbPc.setLocalDescription(offer);
                
                // Wait for ICE gathering
                await new Promise((resolve) => {
                    if (rgbPc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        const checkState = () => {
                            if (rgbPc.iceGatheringState === 'complete') {
                                rgbPc.removeEventListener('icegatheringstatechange', checkState);
                                resolve();
                            }
                        };
                        rgbPc.addEventListener('icegatheringstatechange', checkState);
                        // Timeout after 3 seconds
                        setTimeout(resolve, 3000);
                    }
                });
                
                const response = await fetch(signalingUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sdp: rgbPc.localDescription.sdp,
                        type: rgbPc.localDescription.type
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`RGB signaling failed: ${response.status}`);
                }
                
                const answer = await response.json();
                await rgbPc.setRemoteDescription(new RTCSessionDescription(answer));
                
                console.log('RGB WebRTC connection established');
                rgbRetryCount = 0;  // Reset retry count on success
                
            } catch (err) {
                console.error('RGB WebRTC error:', err);
                rgbRetryCount++;
                
                // Check if it's likely a certificate error
                if (err.message.includes('fetch') || err.message.includes('Failed') || err.name === 'TypeError') {
                    console.log('RGB connection error - SSL certificate may need to be accepted');
                    showRGBCertButton();
                    
                    if (rgbRetryCount <= MAX_RETRIES) {
                        setTimeout(initRGBWebRTC, 5000);
                    }
                } else {
                    console.log('RGB connection error:', err.message);
                    setTimeout(initRGBWebRTC, 3000);
                }
            }
        }
        
        // Show preview of stereo and RGB streams (non-VR mode)
        function startPreview() {
            const stereoVideo = document.getElementById('stereoVideo');
            const rgbVideo = document.getElementById('rgbVideo');
            const previewContainer = document.getElementById('previewContainer');
            const stereoPreview = document.getElementById('preview');
            const rgbPreview = document.getElementById('rgbPreview');
            
            // Create canvases for preview rendering
            const stereoCanvas = document.createElement('canvas');
            const stereoCtx = stereoCanvas.getContext('2d');
            const rgbCanvas = document.createElement('canvas');
            const rgbCtx = rgbCanvas.getContext('2d');
            
            function updatePreview() {
                // Update stereo preview
                if (stereoVideo.readyState >= 2) {
                    stereoCanvas.width = stereoVideo.videoWidth;
                    stereoCanvas.height = stereoVideo.videoHeight;
                    stereoCtx.drawImage(stereoVideo, 0, 0);
                    stereoPreview.src = stereoCanvas.toDataURL('image/jpeg', 0.8);
                }
                
                // Update RGB preview
                if (rgbVideo.readyState >= 2 && rgbConnected) {
                    rgbCanvas.width = rgbVideo.videoWidth;
                    rgbCanvas.height = rgbVideo.videoHeight;
                    rgbCtx.drawImage(rgbVideo, 0, 0);
                    rgbPreview.src = rgbCanvas.toDataURL('image/jpeg', 0.8);
                    rgbPreview.classList.remove('disconnected');
                } else {
                    rgbPreview.classList.add('disconnected');
                }
                
                // Show the container
                previewContainer.classList.remove('hidden');
                
                if (!xrSession) {
                    requestAnimationFrame(updatePreview);
                }
            }
            
            updatePreview();
        }
        
        // Initialize WebXR for VR display
        async function initXR() {
            if (!navigator.xr) {
                setStatus('WebXR not supported', 'error');
                return;
            }
            
            const supported = await navigator.xr.isSessionSupported('immersive-ar');
            if (!supported) {
                setStatus('Immersive AR (passthrough) not supported', 'error');
                document.getElementById('vrButton').disabled = true;
                return;
            }
            
            document.getElementById('vrButton').addEventListener('click', startVRSession);
        }
        
        // Start immersive VR session
        async function startVRSession() {
            try {
                setStatus('Starting VR session...');
                
                // Request immersive AR session for passthrough with stereo overlay
                xrSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['local-floor'],
                    optionalFeatures: ['hand-tracking']
                });
                
                xrSession.addEventListener('end', onSessionEnd);
                
                // Set up WebGL context for XR with alpha for passthrough
                const canvas = document.createElement('canvas');
                gl = canvas.getContext('webgl2', { xrCompatible: true, alpha: true });
                
                if (!gl) {
                    gl = canvas.getContext('webgl', { xrCompatible: true, alpha: true });
                }
                
                await xrSession.updateRenderState({
                    baseLayer: new XRWebGLLayer(xrSession, gl)
                });
                
                xrRefSpace = await xrSession.requestReferenceSpace('local-floor');
                
                // Create textures for left and right eye views
                leftTexture = gl.createTexture();
                rightTexture = gl.createTexture();
                
                // Create texture for RGB panel in VR
                rgbTexture = gl.createTexture();
                
                // Set up canvases for extracting left/right from video
                leftCanvas = document.getElementById('leftCanvas');
                rightCanvas = document.getElementById('rightCanvas');
                leftCtx = leftCanvas.getContext('2d');
                rightCtx = rightCanvas.getContext('2d');
                
                // Set up canvas for RGB video in VR
                rgbCanvas = document.createElement('canvas');
                rgbCtx = rgbCanvas.getContext('2d');
                
                document.getElementById('previewContainer').classList.add('hidden');
                document.getElementById('vrButton').textContent = 'üõë Exit VR';
                document.getElementById('vrButton').onclick = () => xrSession.end();
                
                setStatus('VR Active - Stereo 3D Vision', 'connected');
                
                // Start XR render loop
                xrSession.requestAnimationFrame(onXRFrame);
                
            } catch (err) {
                console.error('VR session error:', err);
                setStatus('VR error: ' + err.message, 'error');
            }
        }
        
        // XR render loop
        function onXRFrame(time, frame) {
            if (!xrSession) return;
            
            xrSession.requestAnimationFrame(onXRFrame);
            
            const pose = frame.getViewerPose(xrRefSpace);
            if (!pose) return;
            
            const glLayer = xrSession.renderState.baseLayer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
            gl.clearColor(0, 0, 0, 0.95);  // 95% opacity for passthrough visibility
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            const video = document.getElementById('stereoVideo');
            if (video.readyState < 2) return;
            
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const halfWidth = videoWidth / 2;
            
            // Update canvas sizes
            if (leftCanvas.width !== halfWidth || leftCanvas.height !== videoHeight) {
                leftCanvas.width = halfWidth;
                leftCanvas.height = videoHeight;
                rightCanvas.width = halfWidth;
                rightCanvas.height = videoHeight;
            }
            
            // Extract left and right images from side-by-side video
            leftCtx.drawImage(video, 0, 0, halfWidth, videoHeight, 0, 0, halfWidth, videoHeight);
            rightCtx.drawImage(video, halfWidth, 0, halfWidth, videoHeight, 0, 0, halfWidth, videoHeight);
            
            // Render to each eye
            for (const view of pose.views) {
                const viewport = glLayer.getViewport(view);
                gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                
                // Select texture based on eye
                const sourceCanvas = view.eye === 'left' ? leftCanvas : rightCanvas;
                const texture = view.eye === 'left' ? leftTexture : rightTexture;
                
                // Update texture from canvas
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, sourceCanvas);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                // Draw fullscreen quad with texture
                drawTexturedQuad(view, viewport);
                
                // Draw RGB panel if connected and enabled
                if (rgbConnected && rgbPanelSettings.enabled) {
                    drawRGBPanel(view, viewport);
                }
            }
        }
        
        // Draw RGB panel in VR (head-locked corner panel)
        function drawRGBPanel(view, viewport) {
            const rgbVideo = document.getElementById('rgbVideo');
            if (!rgbVideo || rgbVideo.readyState < 2) return;
            
            // Update RGB canvas from video
            const vw = rgbVideo.videoWidth;
            const vh = rgbVideo.videoHeight;
            if (vw === 0 || vh === 0) return;
            
            if (rgbCanvas.width !== vw || rgbCanvas.height !== vh) {
                rgbCanvas.width = vw;
                rgbCanvas.height = vh;
            }
            rgbCtx.drawImage(rgbVideo, 0, 0);
            
            // Update RGB texture
            gl.bindTexture(gl.TEXTURE_2D, rgbTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, rgbCanvas);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            
            // Initialize RGB panel shader if needed
            if (!rgbPanelShader) {
                initRGBPanelShader();
            }
            
            gl.useProgram(rgbPanelShader);
            
            // Set up attributes
            const positionLoc = gl.getAttribLocation(rgbPanelShader, 'a_position');
            const texCoordLoc = gl.getAttribLocation(rgbPanelShader, 'a_texCoord');
            
            // Calculate panel dimensions
            const aspect = vw / vh;
            const height = rgbPanelSettings.scale;
            const width = height * aspect;
            const yOff = rgbPanelSettings.yOffset;
            
            // Convert angle to radians for radial positioning
            const angleRad = rgbPanelSettings.angle * Math.PI / 180;
            const dist = rgbPanelSettings.distance;
            
            // Calculate position on cylinder around viewer
            // Panel is at (sin(angle) * distance, yOffset, -cos(angle) * distance)
            // and rotated to face the center
            const xPos = Math.sin(angleRad) * dist;
            const zPos = -Math.cos(angleRad) * dist;
            
            // Update position buffer (panel centered at origin, will be transformed by model matrix)
            gl.bindBuffer(gl.ARRAY_BUFFER, rgbPositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -width/2, -height/2 + yOff,
                 width/2, -height/2 + yOff,
                -width/2,  height/2 + yOff,
                 width/2,  height/2 + yOff,
            ]), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, rgbTexCoordBuffer);
            gl.enableVertexAttribArray(texCoordLoc);
            gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);
            
            // Set uniforms
            const projectionLoc = gl.getUniformLocation(rgbPanelShader, 'u_projection');
            const viewLoc = gl.getUniformLocation(rgbPanelShader, 'u_view');
            const modelLoc = gl.getUniformLocation(rgbPanelShader, 'u_model');
            const textureLoc = gl.getUniformLocation(rgbPanelShader, 'u_texture');
            
            gl.uniformMatrix4fv(projectionLoc, false, view.projectionMatrix);
            
            // Use identity view matrix for head-locked display
            // This keeps the RGB panel fixed relative to the viewer's head
            gl.uniformMatrix4fv(viewLoc, false, new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]));
            
            // Model matrix: rotate around Y axis by angle, then translate to position
            // This places the panel on a cylinder around the viewer, always facing center
            const cosA = Math.cos(angleRad);
            const sinA = Math.sin(angleRad);
            gl.uniformMatrix4fv(modelLoc, false, new Float32Array([
                cosA,  0, sinA, 0,
                0,     1, 0,    0,
                -sinA, 0, cosA, 0,
                xPos,  0, zPos, 1
            ]));
            
            gl.uniform1i(textureLoc, 0);
            
            // Draw quad
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
        
        // Initialize shader for RGB panel (radially positioned, always facing viewer)
        function initRGBPanelShader() {
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, `
                attribute vec2 a_position;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;
                uniform mat4 u_projection;
                uniform mat4 u_view;
                uniform mat4 u_model;
                
                void main() {
                    // Position is in local space, model matrix handles world placement and rotation
                    vec4 pos = vec4(a_position.x, a_position.y, 0.0, 1.0);
                    gl_Position = u_projection * u_view * u_model * pos;
                    v_texCoord = a_texCoord;
                }
            `);
            gl.compileShader(vertexShader);
            
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, `
                precision mediump float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                
                void main() {
                    gl_FragColor = texture2D(u_texture, v_texCoord);
                }
            `);
            gl.compileShader(fragmentShader);
            
            rgbPanelShader = gl.createProgram();
            gl.attachShader(rgbPanelShader, vertexShader);
            gl.attachShader(rgbPanelShader, fragmentShader);
            gl.linkProgram(rgbPanelShader);
            
            // Create buffers
            rgbPositionBuffer = gl.createBuffer();
            rgbTexCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, rgbTexCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0, 1,
                1, 1,
                0, 0,
                1, 0,
            ]), gl.STATIC_DRAW);
        }
        
        // Simple shader program for rendering video texture (supports curved mesh)
        let shaderProgram = null;
        let positionBuffer = null;
        let texCoordBuffer = null;
        let indexBuffer = null;
        let indexCount = 0;
        const CURVE_SEGMENTS = 32;  // Number of horizontal segments for curved screen
        
        function initShaders() {
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, `
                attribute vec3 a_position;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;
                uniform mat4 u_projection;
                uniform mat4 u_view;
                uniform mat4 u_model;
                uniform float u_ipdOffset;
                uniform float u_isLeftEye;
                
                void main() {
                    // Apply IPD offset (inward for each eye to adjust convergence)
                    float xOffset = u_ipdOffset * (u_isLeftEye > 0.5 ? 1.0 : -1.0);
                    vec4 pos = vec4(a_position.x + xOffset, a_position.y, a_position.z, 1.0);
                    gl_Position = u_projection * u_view * u_model * pos;
                    v_texCoord = a_texCoord;
                }
            `);
            gl.compileShader(vertexShader);
            
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, `
                precision mediump float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                
                void main() {
                    gl_FragColor = texture2D(u_texture, v_texCoord);
                }
            `);
            gl.compileShader(fragmentShader);
            
            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            
            // Create buffers
            positionBuffer = gl.createBuffer();
            texCoordBuffer = gl.createBuffer();
            indexBuffer = gl.createBuffer();
            
            // Initialize mesh
            reinitQuadBuffers();
        }
        
        // Generate curved screen mesh
        function generateCurvedMesh(width, height, yOffset, distance, curvature) {
            const positions = [];
            const texCoords = [];
            const indices = [];
            
            const segments = CURVE_SEGMENTS;
            const rows = 2;  // Top and bottom rows
            
            // Calculate the angular span based on width and distance
            // At curvature=1, the screen wraps as if on a cylinder at 'distance' radius
            const arcAngle = (width / distance) * curvature;
            
            for (let row = 0; row <= rows - 1; row++) {
                const v = row / (rows - 1);
                const y = -height/2 + height * v + yOffset;
                
                for (let col = 0; col <= segments; col++) {
                    const u = col / segments;
                    const t = u - 0.5;  // -0.5 to 0.5
                    
                    let x, z;
                    if (curvature < 0.001) {
                        // Flat screen
                        x = t * width;
                        z = -distance;
                    } else {
                        // Curved screen - wrap around cylinder
                        const angle = t * arcAngle;
                        x = Math.sin(angle) * distance;
                        z = -Math.cos(angle) * distance;
                    }
                    
                    positions.push(x, y, z);
                    texCoords.push(u, 1 - v);
                }
            }
            
            // Generate indices for triangle strip converted to triangles
            for (let row = 0; row < rows - 1; row++) {
                for (let col = 0; col < segments; col++) {
                    const topLeft = row * (segments + 1) + col;
                    const topRight = topLeft + 1;
                    const bottomLeft = (row + 1) * (segments + 1) + col;
                    const bottomRight = bottomLeft + 1;
                    
                    // Two triangles per quad
                    indices.push(topLeft, bottomLeft, topRight);
                    indices.push(topRight, bottomLeft, bottomRight);
                }
            }
            
            return { positions, texCoords, indices };
        }
        
        // Reinitialize mesh buffers when settings change
        function reinitQuadBuffers() {
            if (!gl || !positionBuffer) return;
            
            const aspect = 16 / 9;
            const height = stereoSettings.screenScale;
            const width = height * aspect;
            const yOffset = stereoSettings.verticalOffset;
            const distance = stereoSettings.screenDistance;
            const curvature = stereoSettings.curvature;
            
            const mesh = generateCurvedMesh(width, height, yOffset, distance, curvature);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh.positions), gl.STATIC_DRAW);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh.texCoords), gl.STATIC_DRAW);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(mesh.indices), gl.STATIC_DRAW);
            
            indexCount = mesh.indices.length;
        }
        
        function drawTexturedQuad(view, viewport) {
            if (!shaderProgram) {
                initShaders();
            }
            
            gl.useProgram(shaderProgram);
            
            // Set up attributes
            const positionLoc = gl.getAttribLocation(shaderProgram, 'a_position');
            const texCoordLoc = gl.getAttribLocation(shaderProgram, 'a_texCoord');
            
            // Bind position buffer (3D vertices for curved mesh)
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
            
            // Bind texture coordinate buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.enableVertexAttribArray(texCoordLoc);
            gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);
            
            // Bind index buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            
            // Set uniforms
            const projectionLoc = gl.getUniformLocation(shaderProgram, 'u_projection');
            const viewLoc = gl.getUniformLocation(shaderProgram, 'u_view');
            const modelLoc = gl.getUniformLocation(shaderProgram, 'u_model');
            const textureLoc = gl.getUniformLocation(shaderProgram, 'u_texture');
            const ipdOffsetLoc = gl.getUniformLocation(shaderProgram, 'u_ipdOffset');
            const isLeftEyeLoc = gl.getUniformLocation(shaderProgram, 'u_isLeftEye');
            
            gl.uniformMatrix4fv(projectionLoc, false, view.projectionMatrix);
            gl.uniform1f(ipdOffsetLoc, stereoSettings.ipdOffset);
            gl.uniform1f(isLeftEyeLoc, view.eye === 'left' ? 1.0 : 0.0);
            
            // Use identity view matrix for head-locked display
            // This keeps the screen fixed relative to the viewer's head
            gl.uniformMatrix4fv(viewLoc, false, new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]));
            
            // Model matrix - identity (screen at origin, facing -Z)
            gl.uniformMatrix4fv(modelLoc, false, new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]));
            
            gl.uniform1i(textureLoc, 0);
            
            // Draw curved mesh using indexed triangles
            gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0);
        }
        
        // Matrix inversion helper
        function invertMatrix(m, out) {
            const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
            const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
            const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
            const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
            
            const tmp0 = m22 * m33 - m32 * m23;
            const tmp1 = m21 * m33 - m31 * m23;
            const tmp2 = m21 * m32 - m31 * m22;
            const tmp3 = m20 * m33 - m30 * m23;
            const tmp4 = m20 * m32 - m30 * m22;
            const tmp5 = m20 * m31 - m30 * m21;
            
            const t0 = m11 * tmp0 - m12 * tmp1 + m13 * tmp2;
            const t1 = -(m10 * tmp0 - m12 * tmp3 + m13 * tmp4);
            const t2 = m10 * tmp1 - m11 * tmp3 + m13 * tmp5;
            const t3 = -(m10 * tmp2 - m11 * tmp4 + m12 * tmp5);
            
            const det = 1.0 / (m00 * t0 + m01 * t1 + m02 * t2 + m03 * t3);
            
            out[0] = t0 * det;
            out[1] = (-(m01 * tmp0 - m02 * tmp1 + m03 * tmp2)) * det;
            out[2] = (m01 * (m12 * m33 - m32 * m13) - m02 * (m11 * m33 - m31 * m13) + m03 * (m11 * m32 - m31 * m12)) * det;
            out[3] = (-(m01 * (m12 * m23 - m22 * m13) - m02 * (m11 * m23 - m21 * m13) + m03 * (m11 * m22 - m21 * m12))) * det;
            out[4] = t1 * det;
            out[5] = (m00 * tmp0 - m02 * tmp3 + m03 * tmp4) * det;
            out[6] = (-(m00 * (m12 * m33 - m32 * m13) - m02 * (m10 * m33 - m30 * m13) + m03 * (m10 * m32 - m30 * m12))) * det;
            out[7] = (m00 * (m12 * m23 - m22 * m13) - m02 * (m10 * m23 - m20 * m13) + m03 * (m10 * m22 - m20 * m12)) * det;
            out[8] = t2 * det;
            out[9] = (-(m00 * tmp1 - m01 * tmp3 + m03 * tmp5)) * det;
            out[10] = (m00 * (m11 * m33 - m31 * m13) - m01 * (m10 * m33 - m30 * m13) + m03 * (m10 * m31 - m30 * m11)) * det;
            out[11] = (-(m00 * (m11 * m23 - m21 * m13) - m01 * (m10 * m23 - m20 * m13) + m03 * (m10 * m21 - m20 * m11))) * det;
            out[12] = t3 * det;
            out[13] = (m00 * tmp2 - m01 * tmp4 + m02 * tmp5) * det;
            out[14] = (-(m00 * (m11 * m32 - m31 * m12) - m01 * (m10 * m32 - m30 * m12) + m02 * (m10 * m31 - m30 * m11))) * det;
            out[15] = (m00 * (m11 * m22 - m21 * m12) - m01 * (m10 * m22 - m20 * m12) + m02 * (m10 * m21 - m20 * m11)) * det;
        }
        
        function onSessionEnd() {
            xrSession = null;
            gl = null;
            setStatus('VR session ended', '');
            document.getElementById('vrButton').textContent = 'ü•Ω Enter VR';
            document.getElementById('vrButton').onclick = startVRSession;
            document.getElementById('previewContainer').classList.remove('hidden');
            startPreview();
        }
        
        // Make a panel draggable by its header
        function makeDraggable(panelId) {
            const panel = document.getElementById(panelId);
            const header = panel.querySelector('h3');
            let isDragging = false;
            let offsetX, offsetY;
            
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                offsetX = e.clientX - panel.offsetLeft;
                offsetY = e.clientY - panel.offsetTop;
                panel.style.right = 'auto';
                panel.style.left = panel.offsetLeft + 'px';
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                let newX = e.clientX - offsetX;
                let newY = e.clientY - offsetY;
                
                // Keep within viewport bounds
                newX = Math.max(0, Math.min(newX, window.innerWidth - panel.offsetWidth));
                newY = Math.max(0, Math.min(newY, window.innerHeight - panel.offsetHeight));
                
                panel.style.left = newX + 'px';
                panel.style.top = newY + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Touch support for VR headset
            header.addEventListener('touchstart', (e) => {
                isDragging = true;
                const touch = e.touches[0];
                offsetX = touch.clientX - panel.offsetLeft;
                offsetY = touch.clientY - panel.offsetTop;
                panel.style.right = 'auto';
                panel.style.left = panel.offsetLeft + 'px';
            });
            
            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const touch = e.touches[0];
                let newX = touch.clientX - offsetX;
                let newY = touch.clientY - offsetY;
                
                newX = Math.max(0, Math.min(newX, window.innerWidth - panel.offsetWidth));
                newY = Math.max(0, Math.min(newY, window.innerHeight - panel.offsetHeight));
                
                panel.style.left = newX + 'px';
                panel.style.top = newY + 'px';
            }, { passive: false });
            
            document.addEventListener('touchend', () => {
                isDragging = false;
            });
        }
        
        // Make settings panels draggable
        function initDraggable() {
            makeDraggable('controls');
            makeDraggable('rgbControls');
        }
        
        // Initialize on page load
        window.addEventListener('DOMContentLoaded', async () => {
            console.log('Stereo VR Vision - Initializing...');
            loadSettings();
            loadRGBSettings();
            setupControls();
            setupRGBControls();
            initDraggable();
            
            // Initialize both WebRTC streams in parallel
            await Promise.all([
                initStereoWebRTC(),
                initRGBWebRTC()
            ]);
            
            await initXR();
        });
    </script>
</body>
</html>